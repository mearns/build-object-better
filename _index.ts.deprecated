type Primitive = string | number | boolean | bigint | symbol | null | undefined;

/**
 * Represents a key-value pair as a tuple.
 */
type Entry<V> = [string, V];

/**
 * Represents a key-value pair as an object with one
 * property for the key and one property for a value.
 */
type EntryObject<V> = {
  key: string;
  value: V;
};

/**
 * An object whose properties are of a specific type.
 */
type ObjectOf<V> = { [key: string]: V | undefined };

/**
 * A function that can be used for producing keys for a built object.
 */
type KeySupplierFunction<E> = (
  element: E,
  idx?: number,
  all?: Iterable<E>
) => string;

/**
 * An object that can be used for getting keys for a built object when the enumerable
 * elements are strings: the elements key into the object and the corresponding property
 * values are the corresponding keys.
 */
type KeySupplierObject = { [key: string]: string | undefined };

/**
 * An array that provides keys corresponding to elements by index.
 */
type KeyList = String[];

/**
 * The possible types for a key supplier
 */
type KeySupplier<E> =
  | KeySupplierFunction<E>
  | KeyList
  | (E extends string ? KeySupplierObject : never);

/**
 * A function that provides the value of a property for a given
 * key and element.
 */
type ValueSupplierFunction<E, V> = (
  key: string,
  idx?: number,
  keys?: string[],
  elem?: E,
  all?: Iterable<E>
) => V;

/**
 * Returns a new empty object.
 */
export function buildObject<E, V>(): ObjectOf<V>;

/**
 * Build an object as a shallow copy of the given object.
 * @param source The source object.
 */
export function buildObject<E, V>(source: ObjectOf<V>): ObjectOf<V>;

/**
 * @param entries An iterable of Entries, each Entry describing the name of
 * a property and its value.
 */
export function buildObject<E, V>(entries: Iterable<Entry<V>>): ObjectOf<V>;

/**
 * @param entries Build an object from an iterable of Entry objects, each describing one
 * key and one value to define on property of the object.
 */
export function buildObject<E, V>(
  entries: Iterable<EntryObject<V>>
): ObjectOf<V>;

/**
 * The most generic form with control over the generated keys and values.
 * @param source The thing to iterate over and build one property per element.
 * @param keySupplier The thing that translate elements of the `source` into property names.
 * @param valueSupplier The thing that translates property names (from the `keySupplier`) (and optionally elements
 * from the source) into property values.
 */
export function buildObject<E, V>(
  source: Iterable<E>,
  keySupplier: KeySupplier<E>,
  valueSupplier: ValueSupplierFunction<E, V>
): ObjectOf<V>;

export function buildObject<V>(
  source: Iterable<string>,
  keySupplier: KeySupplierObject,
  valueSupplier: ValueSupplierFunction<string, V>
): ObjectOf<V>;

/**
 * Builds an object with the specified property names.
 * @param source The iterable of property names
 * @param valueSupplier The function to supply a value for each property.
 */
export function buildObject<V>(
  source: Iterable<string>,
  valueSupplier: ValueSupplierFunction<string, V>
): ObjectOf<V>;

/**
 * Builds an object with the specified property names and the given fixed value for every property.
 * @param source The iterable of property names
 * @param fixedValue
 */
export function buildObject<V>(
  source: Iterable<string>,
  fixedValue: V
): ObjectOf<V>;

/**
 * Build an object with the same properties as the given source object, but with values
 * generated by the given supplier function.
 * @param source
 * @param valueSupplier
 */
export function buildObject<E, V>(
  source: ObjectOf<E>,
  valueSupplier: ValueSupplierFunction<string, V>
): ObjectOf<V>;

/**
 * Builds an object with the same property names as the given source object, but with the given fixed value for every property.
 * @param source The source of property names.
 * @param fixedValue
 */
export function buildObject<V>(
  source: ObjectOf<any>,
  fixedValue: V
): ObjectOf<V>;

export default function buildObject<E, V>(
  ...args:
    | []
    | [ObjectOf<V> | Iterable<Entry<V> | EntryObject<V>>]
    | [
        E extends string ? Iterable<string> | ObjectOf<string> : ObjectOf<E>,
        ValueSupplierFunction<E, V>
      ]
    | [
        Iterable<E>,
        E extends string ? KeySupplier<E> | KeySupplierObject : KeySupplier<E>,
        ValueSupplierFunction<E, V>
      ]
): ObjectOf<V> {
  switch (args.length) {
    // case 0:
    //   return {};
    case 1:
      return fromOneArg(args[0]);
    case 2:
      return fromTwoArgs(args[0], args[1]);
    case 3:
      return fromThreeArgs(args[0], args[1], args[2]);
    default:
      throw new Error("incorrect number of arguments");
  }
}

function fromOneArg<V>(
  source: ObjectOf<V> | Iterable<Entry<V> | EntryObject<V>>
): ObjectOf<V> {
  if (isIterable(source)) {
    const obj: ObjectOf<V> = {};
    for (const e of source) {
      if (isEntry(e)) {
        obj[e[0]] = e[1];
      } else {
        obj[e.key] = e.value;
      }
    }
    return obj;
  }
  return { ...source };
}

function fromTwoArgs<E, V>(
  source: E extends string ? Iterable<string> | ObjectOf<string> : ObjectOf<E>,
  values: ValueSupplierFunction<E, V> | V[]
): ObjectOf<V> {
  if (isIterable(source)) {
    let idx = 0;
    const kande: Array<[string, string, number]> = [];
    const all: Array<string> = [];
    for (const e of source) {
      kande.push([e, e, idx]);
      all.push(e);
      idx++;
    }
    return buildIt(source, kande, all, values);
  } else {
    let idx = 0;
    const entries: Array<E> = [];
    const kande: Array<[string, E, number]> = [];
    const keys: Array<string> = [];
    for (const k of Object.keys(source)) {
      const e: E = source[k];
      entries.push(e);
      kande.push([k, e, idx]);
      keys.push(k);
      idx++;
    }
    return buildIt(entries, kande, keys, values);
  }
}

function fromThreeArgs<E, V>(
  source: Iterable<E>,
  keys: E extends string ? KeySupplier<E> | KeySupplierObject : KeySupplier<E>,
  values: ValueSupplierFunction<E, V>
): ObjectOf<V> {
  const [kande, allKeys]: [Array<[string, E, number]>, Array<string>] = getKeys(
    source,
    keys
  );
  return buildIt(source, kande, allKeys, values);
}

function buildIt<E, V>(
  source: Iterable<E>,
  kande: Array<[string, E, number]>,
  allKeys: Array<string>,
  values:
    | ValueSupplierFunction<E, V>
    | V[]
    | (Primitive extends V ? V : never)
    | (E extends string ? ObjectOf<V> : never)
): ObjectOf<V> {
  const o: ObjectOf<V> = {};
  if (isValueSupplierFunction(values)) {
    for (const [k, e, i] of kande) {
      o[k] = values(k, i, allKeys, e, source);
    }
  } else if (isValueArray(values)) {
    for (const [k, e, i] of kande) {
      o[k] = values[i];
    }
  } else if (isObjectOf(values)) {
    for (const [k, e, i] of kande) {
      o[k] = values[k];
    }
  } else {
    for (const [k, e, i] of kande) {
      o[k] = values;
    }
  }
  return o;
}

function getKeys<E>(
  source: Iterable<E>,
  keys: E extends string ? KeySupplier<E> | KeySupplierObject : KeySupplier<E>
): [Array<[string, E, number]>, Array<string>] {
  if (isKeySupplier(keys)) {
    if (isKeySupplierFunction(keys)) {
      return keysFromFunc(source, keys);
    }
    return keysFromArray(source, keys);
  }
  return (keysFromObject(
    (source as unknown) as Iterable<string>,
    (keys as unknown) as KeySupplierObject
  ) as unknown) as [Array<[string, E, number]>, Array<string>];
}

function keysFromFunc<E>(
  source: Iterable<E>,
  keys: KeySupplierFunction<E>
): [Array<[string, E, number]>, Array<string>] {
  const kande: Array<[string, E, number]> = [];
  const allKeys: Array<string> = [];
  let idx = 0;
  for (const e of source) {
    const k = keys(e, idx, source);
    kande.push([k, e, idx]);
    allKeys.push(k);
    idx++;
  }
  return [kande, allKeys];
}

function keysFromArray<E>(
  source: Iterable<E>,
  keys: Array<string>
): [Array<[string, E, number]>, Array<string>] {
  const kande: Array<[string, E, number]> = [];
  const allKeys: Array<string> = [];
  let idx = 0;
  for (const e of source) {
    const k = keys[idx];
    kande.push([k, e, idx]);
    allKeys.push(k);
    idx++;
  }
  return [kande, allKeys];
}

function keysFromObject(
  source: Iterable<string>,
  keys: ObjectOf<string>
): [Array<[string, string, number]>, Array<string>] {
  const kande: Array<[string, string, number]> = [];
  const allKeys: Array<string> = [];
  let idx = 0;
  for (const e of source) {
    const k = keys[e];
    kande.push([k, e, idx]);
    allKeys.push(k);
    idx++;
  }
  return [kande, allKeys];
}

function valuesFromObj<E, V>(
  source: Iterable<E>,
  kande: Array<[string, E, number]>,
  allKeys: Array<string>,
  values: ObjectOf<V>
): ObjectOf<V> {
  const o: ObjectOf<V> = {};
  for (const [k, e, i] of kande) {
    o[k] = values[k];
  }
  return o;
}

function valuesFromArray<E, V>(
  source: Iterable<E>,
  kande: Array<[string, E, number]>,
  allKeys: Array<string>,
  values: Array<V>
): ObjectOf<V> {
  const o: ObjectOf<V> = {};
  for (const [k, e, i] of kande) {
    o[k] = values[i];
  }
  return o;
}

function valuesFromConst<E, V>(
  source: Iterable<E>,
  kande: Array<[string, E, number]>,
  allKeys: Array<string>,
  value: V
): ObjectOf<V> {
  const o: ObjectOf<V> = {};
  for (const [k, e, i] of kande) {
    o[k] = value;
  }
  return o;
}

function isObjectOf<V>(
  o: (Primitive extends V ? V : never) | ObjectOf<V>
): o is ObjectOf<V> {
  return typeof o === "object";
}

function isValueArray<V>(
  o: V[] | (Primitive extends V ? V : never) | ObjectOf<V>
): o is V[] {
  return Array.isArray(o);
}

function isValueSupplierFunction<E, V>(
  o:
    | ValueSupplierFunction<E, V>
    | V[]
    | (Primitive extends V ? V : never)
    | (E extends string ? ObjectOf<V> : never)
): o is ValueSupplierFunction<E, V> {
  return typeof o === "function";
}

function isKeySupplierFunction(
  o: KeySupplierFunction<any> | string[]
): o is KeySupplierFunction<any> {
  return typeof o === "function";
}

function isKeySupplier(
  o: KeySupplier<any> | KeySupplierObject | string[]
): o is KeySupplier<any> {
  return typeof o === "function" || Array.isArray(o);
}

function isIterable(o: any): o is Iterable<any> {
  return typeof o[Symbol.iterator] === "function";
}

function isEntry(o: Entry<any> | EntryObject<any>): o is Entry<any> {
  return Array.isArray(o) && o.length === 2 && typeof o[0] === "string";
}
